{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ModelFactory, ModelRelatedNodesI, Neogma, NeogmaInstance } from \"neogma\";\n// import { neogma } from \"../neo4j\";\nimport ts from \"typescript\";\nimport * as R from 'ramda';\nimport fs from 'fs';\nimport _ from 'lodash';\nimport { createLogger, format, transports } from \"winston\";\nimport { consoleFormat } from \"winston-console-format\";\n\n//////////////////////////////////////\n\n///TODO\n///1) type of props Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n// 2) unions (model.generateSpeicifProp)\n// ts.factory.createUnionTypeNode([ // Union type (string | undefined)\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword)\n// ])\n// ts.factory.createArrayLiteralExpression([\n//     ts.factory.createStringLiteral('string'),\n//     ts.factory.createStringLiteral('null')\n// ])\n//3) function for converting model name to file name\n//4) make more than two relations per label in (relation.extractRelationsFromDSL)\n//5) make it more DRY\n//6) add logging\n\n// base\n// config options (generateMethods, generateRelations, generateBase bool)\n// unions & Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n// constraints\n// mofidy exisiting files\n\nexport namespace neogen {\n    export enum FileType {\n        RELATION,\n        MODEL,\n        METHODS,\n        TOTAL,\n        BASE,\n    }\n\n    export enum WriteMode {\n        CREATE_IF_NOT_EXISTS,\n        OVERRIDE\n    }\n    export type PropType = { name: string, type: string }\n\n    export type ctx = {\n        outputFolder: string,\n        generateBase?: boolean\n    }\n\n    type ModelToImport = string\n    export type Types = 'string' | 'boolean' | 'number'\n    export type PropsTypes = { [prop: string]: Types }\n    export type RelationsDSL = Object\n    export type Schema = {\n        label: string,\n        schema: PropsTypes\n    }\n    export type Relation = {\n        from: string,\n        to: string,\n        direction: 'out' | 'in',\n        label: string,\n        alias: string\n    }\n\n    export namespace naming {\n        export const instanceMethodsNameFor = (label: string) => lowerFirstChar(label) + 'InstanceMethods'\n        export const staticMethodsNameFor = (label: string) => lowerFirstChar(label) + 'StaticMethods'\n        export const instanceNameFor = (label: string) => label + 'Instance'\n\n        export const baseInstanceMethods = () => \"baseInstanceMethods\"\n        export const baseStaticMethods = () => \"baseStaticMethods\"\n\n        export namespace file {\n            export const forModel = (label: string) => _.snakeCase(label)\n            export const forModelMethods = (label: string) => '_' + _.snakeCase(label)\n            export const forBaseMethods = () => '__base'\n        }\n    }\n\n    export namespace typing {\n        const typeOfIt = (label: string) => ts.factory.createTypeQueryNode(ts.factory.createIdentifier(label))\n\n        export const instanceMethodsNameFor = (label: string) => typeOfIt(naming.instanceMethodsNameFor(label))\n        export const staticMethodsNameFor = (label: string) => typeOfIt(naming.staticMethodsNameFor(label))\n    }\n\n    export namespace imports {\n\n        const importSpecifierFromName = (name: string) =>\n            ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier(name))\n\n\n        export function generateBaseImports() {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        naming.baseInstanceMethods(),\n                        naming.baseStaticMethods(),\n                    ].map(importSpecifierFromName))\n                ),\n                ts.factory.createStringLiteral('./' + naming.file.forBaseMethods()), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateMethodsImport(modelName: string) {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        naming.instanceMethodsNameFor(modelName),\n                        naming.staticMethodsNameFor(modelName),\n                    ].map(importSpecifierFromName))\n                ),\n                ts.factory.createStringLiteral('./' + naming.file.forModelMethods(modelName)), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateStaticImports() {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        'ModelFactory',\n                        'ModelRelatedNodesI',\n                        'NeogmaInstance',\n                    ].map(importSpecifierFromName))\n                ),\n                ts.factory.createStringLiteral(\"neogma\"), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateNeogenImport() {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        importSpecifierFromName('neogen')\n                    ])\n                ),\n                ts.factory.createStringLiteral('neogen'), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateAllImportsOfModel(modelName: string): ts.Node {\n            const toImport = [\n                modelName,\n                modelName + 'Instance',\n                modelName + 'Props',\n                modelName + 'RelatedNodesI',\n            ].map(importSpecifierFromName)\n\n            const importFrom = './' + naming.file.forModel(modelName)\n\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports(toImport)\n                ),\n                ts.factory.createStringLiteral(importFrom), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n\n    }\n\n    export namespace model {\n        function generatePropsType(schema: Schema): ts.TypeAliasDeclaration {\n            const propsTypes = Object.entries(schema.schema)\n                .map(([name, typeName]) => createPropertySignature(\n                    name,\n                    ts.factory.createKeywordTypeNode(typeMapping[typeName])\n                ))\n\n            return ts.factory.createTypeAliasDeclaration(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                schema.label + 'Props',\n                undefined,\n                ts.factory.createTypeLiteralNode(propsTypes)\n            )\n        }\n\n        export function generateComposed(ctx: ctx, schema: Schema, relations: Relation[]): ts.Node[] {\n            const [relationNodes, toImport] = relation.generateRelationsType(schema.label, relations)\n\n            const importBody: ts.Node[] = [\n                imports.generateStaticImports(),\n                imports.generateMethodsImport(schema.label),\n                imports.generateNeogenImport(),\n                ...R.uniq(toImport).map(imports.generateAllImportsOfModel),\n            ]\n\n            const body = [\n                generateInstanceType(schema.label),\n                generatePropsType(schema),\n                relationNodes,\n                generateModel(schema),\n            ].flatMap(it => [it, ts.factory.createEmptyStatement()])\n\n            return [\n                ...importBody, ...body\n            ]\n        }\n\n        function generateSpeicifProp(prop: PropType) {\n            return ts.factory.createPropertyAssignment(\n                prop.name,\n                ts.factory.createObjectLiteralExpression([\n                    ts.factory.createPropertyAssignment(\n                        'type',\n                        ts.factory.createStringLiteral(prop.type),\n                    )\n                ], false)\n            )\n        }\n\n        function generateModel(schema: Schema) {\n            const neogmaInstance =\n                ts.factory.createCallExpression(\n                    ts.factory.createPropertyAccessExpression(\n                        ts.factory.createIdentifier('neogen'),\n                        ts.factory.createIdentifier('get')\n                    ),\n                    undefined,\n                    [])\n\n            const modelFactoryCall = ts.factory.createCallExpression(\n                ts.factory.createIdentifier('ModelFactory'), // Expression\n                [\n                    ts.factory.createTypeReferenceNode(schema.label + 'Props', undefined),\n                    ts.factory.createTypeReferenceNode(schema.label + 'RelatedNodesI', undefined),\n                    typing.staticMethodsNameFor(schema.label),\n                    typing.instanceMethodsNameFor(schema.label),\n\n                ],\n                [\n                    ts.factory.createObjectLiteralExpression([\n                        ts.factory.createPropertyAssignment(\n                            'methods', ts.factory.createIdentifier(naming.instanceMethodsNameFor(schema.label))\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'statics', ts.factory.createIdentifier(naming.staticMethodsNameFor(schema.label))\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'label',\n                            ts.factory.createStringLiteral(schema.label)\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'schema',\n                            ts.factory.createObjectLiteralExpression(\n                                Object.entries(schema.schema).map(([name, type]) => generateSpeicifProp({ name, type })) as any// schema.schema\n                                , true)\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'primaryKeyField',\n                            ts.factory.createStringLiteral('uuid')\n                        ),\n                    ], true),\n                    neogmaInstance\n                ]\n            );\n\n            const modelConst = ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [ts.factory.createVariableDeclaration(\n                        schema.label,\n                        undefined,\n                        undefined,\n                        modelFactoryCall\n                    )],\n                    ts.NodeFlags.Const\n                )\n            );\n\n            return modelConst\n        }\n    }\n\n    export namespace methods {\n        function generateStaticMethods(ctx: ctx, label: string): ts.Node {\n            const objectContent: ts.ObjectLiteralElementLike[] = []\n\n            if (ctx.generateBase) {\n                objectContent.push(\n                    ts.factory.createSpreadAssignment(ts.factory.createIdentifier(naming.baseStaticMethods()))\n                )\n            }\n\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.staticMethodsNameFor(label)),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression(objectContent, false)\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n        }\n\n        function generateInstanceMethods(ctx: ctx, label: string): ts.Node {\n            const objectContent: ts.ObjectLiteralElementLike[] = []\n\n            if (ctx.generateBase) {\n                objectContent.push(\n                    ts.factory.createSpreadAssignment(ts.factory.createIdentifier(naming.baseInstanceMethods()))\n                )\n            }\n\n            const body = ts.factory.createBlock([\n                ts.factory.createReturnStatement(\n                    ts.factory.createAsExpression(\n                        ts.factory.createAsExpression(\n                            ts.factory.createThis(),\n                            ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n                        ),\n                        ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(naming.instanceNameFor(label)), undefined)\n                    )\n                )\n            ], true)\n\n            const selfMethod = ts.factory.createMethodDeclaration(\n                undefined,\n                undefined,\n                ts.factory.createIdentifier(\"self\"),\n                undefined,\n                undefined,\n                [],\n                undefined,\n                body\n            )\n\n            objectContent.push(selfMethod)\n\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.instanceMethodsNameFor(label)),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression(\n                                objectContent,\n                                false\n                            )\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n\n        }\n\n        export function generateMethodFilesOf(ctx: ctx, files: GenerateSourceFile[]): GenerateSourceFile[] {\n            const importsBody: ts.Node[] = []\n\n            if (ctx.generateBase) {\n                importsBody.push(imports.generateBaseImports())\n            }\n\n            const mapToDeclaration =\n                (file: GenerateSourceFile) => [\n                    imports.generateAllImportsOfModel(file.modelName!),\n                    ...importsBody,\n                    generateStaticMethods(ctx, file.modelName!),\n                    generateInstanceMethods(ctx, file.modelName!)\n                ]\n            return files.map(_ => new GenerateSourceFile(_.modelName, mapToDeclaration(_), FileType.METHODS))\n        }\n    }\n\n\n    export namespace base {\n\n        function generateStaticMethodsBase(): ts.Node {\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.baseStaticMethods()),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression([], false)\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n        }\n\n        function generateInstanceMethodsBase(): ts.Node {\n\n\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.baseInstanceMethods()),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression([], false)\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n\n        }\n\n\n        export function generateBase(): ts.Node[] {\n            return [\n                generateStaticMethodsBase(),\n                generateInstanceMethodsBase(),\n            ]\n        }\n    }\n\n    export namespace relation {\n\n        export function extractRelationsFromDSL(dsl: Object): Relation[] {\n            return Object.entries(dsl)\n                .flatMap(([label, entry]) => {\n                    const [[from, alias], [fromB, aliasB]] = Object.entries(entry) as string[][]\n\n                    const inRel: Relation = {\n                        from,\n                        to: fromB,\n                        direction: 'out',\n                        label,\n                        alias\n                    }\n\n                    const outRel: Relation = {\n                        from: fromB,\n                        to: from,\n                        direction: 'in',\n                        label: label,\n                        alias: aliasB\n                    }\n\n                    return [inRel, outRel]\n                })\n        }\n\n\n        export function generateRelationsType(modelLabel: string, relations: Relation[]): [ts.InterfaceDeclaration, ModelToImport[]] {\n            const relationSchema = R.groupBy(rel => rel.from, relations)[modelLabel]!\n\n            const needToImportModels: string[] = relationSchema.map(rel => rel.to)\n\n            const modelRelations = relationSchema\n                .map(rel =>\n                    createPropertySignature(\n                        rel.alias,\n                        ts.factory.createTypeReferenceNode('ModelRelatedNodesI', [\n                            ts.factory.createTypeQueryNode(ts.factory.createIdentifier(rel.to)),\n                            ts.factory.createTypeReferenceNode(rel.to + 'Instance', undefined),\n                        ])))\n\n            const resultRelations = ts.factory.createInterfaceDeclaration(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                modelLabel + 'RelatedNodesI',\n                undefined,\n                undefined,\n                modelRelations,\n            );\n            return [resultRelations, needToImportModels]\n        }\n\n        export function generateRelationFile(rels: Relation[]): ts.Node[] {\n            const models = R.uniq(rels.flatMap(rel => [rel.from, rel.to]))\n\n            return [\n                ...models.map(imports.generateAllImportsOfModel),\n                ...rels.map(generateRelationInit)\n            ]\n        }\n\n        export function generateRelationInit(relation: Relation): ts.Node {\n            const traget = [\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('model'),\n                    ts.factory.createIdentifier(relation.to)\n                ),\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('direction'),\n                    ts.factory.createStringLiteral(relation.direction)\n                ),\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('name'),\n                    ts.factory.createStringLiteral(relation.label)\n                )\n            ];\n\n            return ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(relation.from),\n                    ts.factory.createIdentifier('addRelationships')\n                ),\n                undefined,\n                [\n                    ts.factory.createObjectLiteralExpression(\n                        [\n                            ts.factory.createPropertyAssignment(\n                                ts.factory.createIdentifier(relation.alias),\n                                ts.factory.createObjectLiteralExpression(\n                                    traget,\n                                    true // This flag is for multiline object literals\n                                )\n                            )\n                        ],\n                        true // This flag is for multiline object literals\n                    )\n                ]\n            )\n        }\n    }\n\n    const lowerFirstChar = (str: string) =>\n        str.charAt(0).toLowerCase() + str.slice(1)\n\n    const createPropertySignature = (name: string, type: ts.TypeNode) =>\n        ts.factory.createPropertySignature(undefined, name, undefined, type)\n\n\n    const typeMapping: { [key: string]: ts.KeywordTypeSyntaxKind } = {\n        'string': ts.SyntaxKind.StringKeyword,\n        'boolean': ts.SyntaxKind.BooleanKeyword,\n        'number': ts.SyntaxKind.NumberKeyword,\n    }\n\n\n    function generateInstanceType(label: string): ts.TypeAliasDeclaration {\n\n        const instanceMethodsName = naming.instanceMethodsNameFor(label)\n\n        const neogmaInstanceType = ts.factory.createTypeReferenceNode('NeogmaInstance', [\n            ts.factory.createTypeReferenceNode(label + 'Props', undefined),\n            ts.factory.createTypeReferenceNode(label + 'RelatedNodesI', undefined),\n            ts.factory.createTypeQueryNode(ts.factory.createIdentifier(instanceMethodsName))\n        ]);\n\n        return ts.factory.createTypeAliasDeclaration(\n            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n            label + 'Instance',\n            [], // Type parameters\n            neogmaInstanceType,\n        );\n    }\n\n    const generatedFileClaim = '// GENERATED FILE, MAY CHANGE IN FUTURE, DO NOT EDIT IT MANUALLY\\n'\n\n    class GenerateSourceFile {\n        constructor(\n            readonly modelName: string | null | undefined,\n            readonly nodes: ts.Node[],\n            readonly type: FileType,\n        ) { }\n\n        save(ctx: ctx) {\n            const resultFile = ts.createSourceFile(\"\", \"\", ts.ScriptTarget.Latest, false, ts.ScriptKind.TSX);\n            const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n            let printedNodes = this.nodes.map(node => printer.printNode(ts.EmitHint.Unspecified, node, resultFile)).join('\\n');\n\n            const resultCode = this.obtainWriteMode() == WriteMode.OVERRIDE ?\n                generatedFileClaim + printedNodes :\n                printedNodes\n\n\n            fs.mkdirSync(ctx.outputFolder, { recursive: true });\n\n            const pathToFile = `${ctx.outputFolder}/${this.obtainFileName()}`\n            const fileExists = fs.existsSync(pathToFile)\n\n            const minimalInfo = {\n                path: pathToFile,\n                model: this.modelName,\n                type: this.type,\n            }\n\n            if (this.obtainWriteMode() == WriteMode.CREATE_IF_NOT_EXISTS) {\n                if (!fileExists) {\n                    fs.writeFileSync(pathToFile, resultCode);\n                    logger.verbose('Created new file', minimalInfo)\n                } else {\n                    logger.warn('File exists, skipped', minimalInfo)\n                }\n            } else if (this.obtainWriteMode() == WriteMode.OVERRIDE) {\n                fs.writeFileSync(pathToFile, resultCode);\n                if (fileExists) {\n                    logger.verbose('File overridden:', minimalInfo);\n                } else {\n                    logger.verbose('New file created:', minimalInfo);\n                }\n            } else {\n                logger.error('Nothing to do with this kind of file', minimalInfo)\n            }\n        }\n\n        obtainFileName(): string {\n            return R.cond([\n                [R.equals(FileType.MODEL), R.always(naming.file.forModel(this.modelName!))],\n                [R.equals(FileType.METHODS), R.always(naming.file.forModelMethods(this.modelName!))],\n                [R.equals(FileType.RELATION), R.always('__relations')],\n                [R.equals(FileType.BASE), R.always('__base')],\n            ])(this.type) + '.ts'\n        }\n\n        obtainWriteMode(): WriteMode {\n            return R.cond([\n                [R.equals(FileType.MODEL), R.always(WriteMode.OVERRIDE)],\n                [R.equals(FileType.RELATION), R.always(WriteMode.OVERRIDE)],\n                [R.T, R.always(WriteMode.CREATE_IF_NOT_EXISTS)]\n            ])(this.type)\n        }\n    }\n\n    const logger = createLogger({\n        level: \"silly\",\n        format: format.combine(\n            format.timestamp(),\n            format.ms(),\n            format.errors({ stack: true }),\n            format.splat(),\n            format.json()\n        ),\n        defaultMeta: { service: \"Test\" },\n        transports: [\n            new transports.Console({\n                format: format.combine(\n                    format.colorize({ all: true }),\n                    format.padLevels(),\n                    consoleFormat({\n                        showMeta: true,\n                        metaStrip: [\"timestamp\", \"service\"],\n                        inspectOptions: {\n                            depth: Infinity,\n                            colors: true,\n                            maxArrayLength: Infinity,\n                            breakLength: 120,\n                            compact: Infinity,\n                        },\n                    })\n                ),\n            }),\n        ],\n    });\n\n\n    export function generateAll(ctx: ctx, schemas: Schema[], relations: RelationsDSL) {\n        logger.silly(\"Started neogen\")\n        const parsedRelations = relation.extractRelationsFromDSL(relations)\n        logger.info(\"Parsed relations DSL\")\n\n        const sources = schemas.map((schema) =>\n            new GenerateSourceFile(\n                schema.label,\n                model.generateComposed(ctx, schema, parsedRelations),\n                FileType.MODEL));\n        logger.info(\"Generated types and props defenitions\")\n\n        sources.push(...methods.generateMethodFilesOf(ctx, sources))\n        logger.info(\"Generated methods files\")\n\n        sources.push(new GenerateSourceFile(null, relation.generateRelationFile(parsedRelations), FileType.RELATION))\n        logger.info(\"Generated relations file\")\n\n        if (ctx.generateBase) {\n            sources.push(new GenerateSourceFile(null, base.generateBase(), FileType.BASE))\n            logger.info(\"Generated base file\")\n        }\n\n        sources.map(it => it.save(ctx))\n\n        logger.silly('Done')\n    }\n\n    function print(nodes: any) {\n        const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n        const resultFile = ts.createSourceFile(\n            \"\",\n            \"\",\n            ts.ScriptTarget.Latest,\n            false,\n            ts.ScriptKind.TSX\n        );\n\n        const result = printer.printList(ts.ListFormat.MultiLine, nodes, resultFile);\n\n        console.log(\n            result.split(';\\n').join('\\n'))\n\n    }\n\n    let instance: Neogma\n\n    export function get(): Neogma {\n        if (!instance) {\n            throw new Error('Ensure you call neogen.setInstance(noegmaInstance) and all imported in right order')\n        }\n        return instance\n    }\n\n    export function setInstance(val: Neogma): void {\n        instance = val\n    }\n\n}\n\n//////////////////////////////////////\n\n"],"mappings":"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","names":["neogen","FileType","WriteMode","naming","file","typing","imports","model","methods","_","base","relation"]}