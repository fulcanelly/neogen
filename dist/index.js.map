{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ModelFactory, ModelRelatedNodesI, Neogma, NeogmaInstance } from \"neogma\";\n// import { neogma } from \"../neo4j\";\nimport ts from \"typescript\";\nimport * as R from 'ramda';\nimport fs from 'fs';\nimport _ from 'lodash';\nimport { createLogger, format, transports } from \"winston\";\nimport { consoleFormat } from \"winston-console-format\";\n\n//////////////////////////////////////\n\n///TODO\n///1) type of props Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n// 2) unions (model.generateSpeicifProp)\n// ts.factory.createUnionTypeNode([ // Union type (string | undefined)\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword)\n// ])\n// ts.factory.createArrayLiteralExpression([\n//     ts.factory.createStringLiteral('string'),\n//     ts.factory.createStringLiteral('null')\n// ])\n//3) function for converting model name to file name\n//4) make more than two relations per label in (relation.extractRelationsFromDSL)\n//5) make it more DRY\n//6) add logging\n\n// base\n// config options (generateMethods, generateRelations, generateBase bool)\n// unions & Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n// constraints\n// mofidy exisiting files\n\n// relation validation: error unknown model\n// sample\n// common schema\n// update readme\n\nexport namespace neogen {\n  export enum FileType {\n    RELATION,\n    MODEL,\n    METHODS,\n    TOTAL,\n    BASE,\n  }\n\n  export enum WriteMode {\n    CREATE_IF_NOT_EXISTS,\n    OVERRIDE\n  }\n  export type PropType = { name: string, type: Types }\n\n  export type ctx = {\n    outputFolder: string,\n    generateBase?: boolean\n  }\n\n  type ModelToImport = string\n\n  type BasicTypes = Revalidator.Types\n  export type Types = undefined | BasicTypes | BasicTypes[] | Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n  export type PropsTypes = { [prop: string]: Types }\n  export type RelationsDSL = Object\n  export type Schema = {\n    label: string,\n    schema: PropsTypes\n  }\n  export type Relation = {\n    from: string,\n    to: string,\n    direction: 'out' | 'in',\n    label: string,\n    alias: string\n  }\n\n  export namespace naming {\n    export const instanceMethodsNameFor = (label: string) => lowerFirstChar(label) + 'InstanceMethods'\n    export const staticMethodsNameFor = (label: string) => lowerFirstChar(label) + 'StaticMethods'\n    export const instanceNameFor = (label: string) => label + 'Instance'\n\n    export const baseInstanceMethods = () => \"baseInstanceMethods\"\n    export const baseStaticMethods = () => \"baseStaticMethods\"\n\n    export namespace file {\n      export const forModel = (label: string) => _.snakeCase(label)\n      export const forModelMethods = (label: string) => '_' + _.snakeCase(label)\n      export const forBaseMethods = () => '__base'\n    }\n  }\n\n  export namespace typing {\n    const typeOfIt = (label: string) => ts.factory.createTypeQueryNode(ts.factory.createIdentifier(label))\n\n    export const instanceMethodsNameFor = (label: string) => typeOfIt(naming.instanceMethodsNameFor(label))\n    export const staticMethodsNameFor = (label: string) => typeOfIt(naming.staticMethodsNameFor(label))\n  }\n\n  export namespace imports {\n\n    const importSpecifierFromName = (name: string) =>\n      ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier(name))\n\n\n    export function generateBaseImports() {\n      return ts.factory.createImportDeclaration(\n        undefined, // modifiers array\n        ts.factory.createImportClause(\n          false, // IsTypeOnly\n          undefined, // No namespace import\n          ts.factory.createNamedImports([\n            naming.baseInstanceMethods(),\n            naming.baseStaticMethods(),\n          ].map(importSpecifierFromName))\n        ),\n        ts.factory.createStringLiteral('./' + naming.file.forBaseMethods()), // module specifier\n        undefined  // assert clause\n      );\n    }\n\n    export function generateMethodsImport(modelName: string) {\n      return ts.factory.createImportDeclaration(\n        undefined, // modifiers array\n        ts.factory.createImportClause(\n          false, // IsTypeOnly\n          undefined, // No namespace import\n          ts.factory.createNamedImports([\n            naming.instanceMethodsNameFor(modelName),\n            naming.staticMethodsNameFor(modelName),\n          ].map(importSpecifierFromName))\n        ),\n        ts.factory.createStringLiteral('./' + naming.file.forModelMethods(modelName)), // module specifier\n        undefined  // assert clause\n      );\n    }\n\n    export function generateStaticImports() {\n      return ts.factory.createImportDeclaration(\n        undefined, // modifiers array\n        ts.factory.createImportClause(\n          false, // IsTypeOnly\n          undefined, // No namespace import\n          ts.factory.createNamedImports([\n            'ModelFactory',\n            'ModelRelatedNodesI',\n            'NeogmaInstance',\n          ].map(importSpecifierFromName))\n        ),\n        ts.factory.createStringLiteral(\"neogma\"), // module specifier\n        undefined  // assert clause\n      );\n    }\n\n    export function generateNeogenImport() {\n      return ts.factory.createImportDeclaration(\n        undefined, // modifiers array\n        ts.factory.createImportClause(\n          false, // IsTypeOnly\n          undefined, // No namespace import\n          ts.factory.createNamedImports([\n            importSpecifierFromName('neogen')\n          ])\n        ),\n        ts.factory.createStringLiteral('neogen'), // module specifier\n        undefined  // assert clause\n      );\n    }\n\n    export function generateAllImportsOfModel(modelName: string): ts.Node {\n      const toImport = [\n        modelName,\n        modelName + 'Instance',\n        modelName + 'Props',\n        modelName + 'RelatedNodesI',\n      ].map(importSpecifierFromName)\n\n      const importFrom = './' + naming.file.forModel(modelName)\n\n      return ts.factory.createImportDeclaration(\n        undefined, // modifiers array\n        ts.factory.createImportClause(\n          false, // IsTypeOnly\n          undefined, // No namespace import\n          ts.factory.createNamedImports(toImport)\n        ),\n        ts.factory.createStringLiteral(importFrom), // module specifier\n        undefined  // assert clause\n      );\n    }\n  }\n\n  export namespace common {\n    export function straightforwardConvertValue(value: any): ts.Expression {\n      if (typeof value == 'string') {\n        return ts.factory.createStringLiteral(value)\n      }\n\n      if (typeof value == 'number') {\n        return ts.factory.createNumericLiteral(value)\n      }\n\n      if (typeof value == 'boolean') {\n        return value ?\n          ts.factory.createTrue() :\n          ts.factory.createFalse()\n      }\n\n      if (value instanceof Array) {\n        return ts.factory.createArrayLiteralExpression(\n          value.map(straightforwardConvertValue))\n      }\n\n      if (value instanceof Object) {\n        return straightforwardObjectConvert(value)\n      }\n\n      console.log(value)\n      throw 'Non supported type'\n    }\n\n    export function straightforwardObjectConvert(object: Object): ts.Expression {\n      return ts.factory.createObjectLiteralExpression(\n        Object.entries(object).map(([key, value]) =>\n          ts.factory.createPropertyAssignment(key, straightforwardConvertValue(value))\n        ),\n        true\n      );\n    }\n  }\n\n  export namespace model {\n\n    export namespace props {\n      export function extractTypeFromSchemeType(typeDefenition: Types): ts.TypeNode {\n        if (typeof typeDefenition == 'string') {\n          return ts.factory.createKeywordTypeNode(typeMapping[typeDefenition]) as ts.TypeNode\n        }\n\n        if (typeDefenition instanceof Array) {\n          return ts.factory.createUnionTypeNode([\n            ...typeDefenition.map(extractTypeFromSchemeType)\n          ])\n        }\n\n        if (typeDefenition instanceof Object) {\n          const adjusted = typeDefenition as Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n          return extractTypeFromSchemeType(adjusted.type)\n        }\n\n        throw 'Unknown type format'\n      }\n\n\n      export function generatePropsType(schema: Schema): ts.TypeAliasDeclaration {\n        const propsTypes = Object.entries(schema.schema)\n          .map(([name, typeName]) => createPropertySignature(\n            name,\n            extractTypeFromSchemeType(typeName)\n          ))\n\n        return ts.factory.createTypeAliasDeclaration(\n          [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n          schema.label + 'Props',\n          undefined,\n          ts.factory.createTypeLiteralNode(propsTypes)\n        )\n      }\n    }\n\n    export namespace instance {\n      function createSimpleTypeDef(value: ts.Expression): ts.Expression {\n        return ts.factory.createObjectLiteralExpression([\n          ts.factory.createPropertyAssignment(\n            'type', value)\n        ])\n      }\n\n      export function generatePropTypeExpression(type: Types): ts.Expression {\n        if (type === undefined) {\n          throw new Error(\"Type is undefined\");\n        }\n\n        if (typeof type === 'string') {\n          return createSimpleTypeDef(ts.factory.createStringLiteral(type));\n        } if (type instanceof Array) {\n          const typeArray =\n            ts.factory.createArrayLiteralExpression(\n              type.map(t => ts.factory.createStringLiteral(t)))\n\n          return createSimpleTypeDef(typeArray)\n        } else if (type instanceof Object) {\n          return common.straightforwardObjectConvert(type)\n        } else {\n          throw new Error(\"Invalid type\");\n        }\n      }\n\n      function generateSpeicifProp(prop: PropType) {\n        return ts.factory.createPropertyAssignment(\n          prop.name,\n          generatePropTypeExpression(prop.type)\n        )\n      }\n\n      export function generateModel(schema: Schema) {\n        const neogmaInstance =\n          ts.factory.createCallExpression(\n            ts.factory.createPropertyAccessExpression(\n              ts.factory.createIdentifier('neogen'),\n              ts.factory.createIdentifier('get')\n            ),\n            undefined,\n            [])\n\n        const modelFactoryCall = ts.factory.createCallExpression(\n          ts.factory.createIdentifier('ModelFactory'), // Expression\n          [\n            ts.factory.createTypeReferenceNode(schema.label + 'Props', undefined),\n            ts.factory.createTypeReferenceNode(schema.label + 'RelatedNodesI', undefined),\n            typing.staticMethodsNameFor(schema.label),\n            typing.instanceMethodsNameFor(schema.label),\n\n          ],\n          [\n            ts.factory.createObjectLiteralExpression([\n              ts.factory.createPropertyAssignment(\n                'methods', ts.factory.createIdentifier(naming.instanceMethodsNameFor(schema.label))\n              ),\n              ts.factory.createPropertyAssignment(\n                'statics', ts.factory.createIdentifier(naming.staticMethodsNameFor(schema.label))\n              ),\n              ts.factory.createPropertyAssignment(\n                'label',\n                ts.factory.createStringLiteral(schema.label)\n              ),\n              ts.factory.createPropertyAssignment(\n                'schema',\n                ts.factory.createObjectLiteralExpression(\n                  Object.entries(schema.schema).map(([name, type]) => generateSpeicifProp({ name, type }))\n                  , true)\n              ),\n              ts.factory.createPropertyAssignment(\n                'primaryKeyField',\n                ts.factory.createStringLiteral('uuid')\n              ),\n            ], true),\n            neogmaInstance\n          ]\n        );\n\n        const modelConst = ts.factory.createVariableStatement(\n          [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n          ts.factory.createVariableDeclarationList(\n            [ts.factory.createVariableDeclaration(\n              schema.label,\n              undefined,\n              undefined,\n              modelFactoryCall\n            )],\n            ts.NodeFlags.Const\n          )\n        );\n\n        return modelConst\n      }\n    }\n\n    function generateInstanceType(label: string): ts.TypeAliasDeclaration {\n\n      const instanceMethodsName = naming.instanceMethodsNameFor(label)\n\n      const neogmaInstanceType = ts.factory.createTypeReferenceNode('NeogmaInstance', [\n        ts.factory.createTypeReferenceNode(label + 'Props', undefined),\n        ts.factory.createTypeReferenceNode(label + 'RelatedNodesI', undefined),\n        ts.factory.createTypeQueryNode(ts.factory.createIdentifier(instanceMethodsName))\n      ]);\n\n      return ts.factory.createTypeAliasDeclaration(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        label + 'Instance',\n        [], // Type parameters\n        neogmaInstanceType,\n      );\n    }\n\n    export function generateComposed(ctx: ctx, schema: Schema, relations: Relation[]): ts.Node[] {\n      const [relationNodes, toImport] = relation.generateRelationsType(schema.label, relations)\n\n      const importBody: ts.Node[] = [\n        imports.generateStaticImports(),\n        imports.generateMethodsImport(schema.label),\n        imports.generateNeogenImport(),\n        ...R.uniq(toImport).map(imports.generateAllImportsOfModel),\n      ]\n\n      const body = [\n        generateInstanceType(schema.label),\n        props.generatePropsType(schema),\n        relationNodes,\n        instance.generateModel(schema),\n      ].flatMap(it => [it, ts.factory.createEmptyStatement()])\n\n      return [\n        ...importBody, ...body\n      ]\n    }\n\n\n  }\n\n  export namespace methods {\n    function generateStaticMethods(ctx: ctx, label: string): ts.Node {\n      const objectContent: ts.ObjectLiteralElementLike[] = []\n\n      if (ctx.generateBase) {\n        objectContent.push(\n          ts.factory.createSpreadAssignment(ts.factory.createIdentifier(naming.baseStaticMethods()))\n        )\n      }\n\n      return ts.factory.createVariableStatement(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              ts.factory.createIdentifier(naming.staticMethodsNameFor(label)),\n              undefined,\n              undefined,\n              ts.factory.createObjectLiteralExpression(objectContent, false)\n            )\n          ],\n          ts.NodeFlags.Const\n        )\n      );\n    }\n\n    function generateInstanceMethods(ctx: ctx, label: string): ts.Node {\n      const objectContent: ts.ObjectLiteralElementLike[] = []\n\n      if (ctx.generateBase) {\n        objectContent.push(\n          ts.factory.createSpreadAssignment(ts.factory.createIdentifier(naming.baseInstanceMethods()))\n        )\n      }\n\n      const body = ts.factory.createBlock([\n        ts.factory.createReturnStatement(\n          ts.factory.createAsExpression(\n            ts.factory.createAsExpression(\n              ts.factory.createThis(),\n              ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n            ),\n            ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(naming.instanceNameFor(label)), undefined)\n          )\n        )\n      ], true)\n\n      const selfMethod = ts.factory.createMethodDeclaration(\n        undefined,\n        undefined,\n        ts.factory.createIdentifier(\"self\"),\n        undefined,\n        undefined,\n        [],\n        undefined,\n        body\n      )\n\n      objectContent.push(selfMethod)\n\n      return ts.factory.createVariableStatement(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              ts.factory.createIdentifier(naming.instanceMethodsNameFor(label)),\n              undefined,\n              undefined,\n              ts.factory.createObjectLiteralExpression(\n                objectContent,\n                false\n              )\n            )\n          ],\n          ts.NodeFlags.Const\n        )\n      );\n\n    }\n\n    export function generateMethodFilesOf(ctx: ctx, files: GenerateSourceFile[]): GenerateSourceFile[] {\n      const importsBody: ts.Node[] = []\n\n      if (ctx.generateBase) {\n        importsBody.push(imports.generateBaseImports())\n      }\n\n      const mapToDeclaration =\n        (file: GenerateSourceFile) => [\n          imports.generateAllImportsOfModel(file.modelName!),\n          ...importsBody,\n          generateStaticMethods(ctx, file.modelName!),\n          generateInstanceMethods(ctx, file.modelName!)\n        ]\n      return files.map(_ => new GenerateSourceFile(_.modelName, mapToDeclaration(_), FileType.METHODS))\n    }\n  }\n\n\n  export namespace base {\n\n    function generateStaticMethodsBase(): ts.Node {\n      return ts.factory.createVariableStatement(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              ts.factory.createIdentifier(naming.baseStaticMethods()),\n              undefined,\n              undefined,\n              ts.factory.createObjectLiteralExpression([], false)\n            )\n          ],\n          ts.NodeFlags.Const\n        )\n      );\n    }\n\n    function generateInstanceMethodsBase(): ts.Node {\n\n\n      return ts.factory.createVariableStatement(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.factory.createVariableDeclarationList(\n          [\n            ts.factory.createVariableDeclaration(\n              ts.factory.createIdentifier(naming.baseInstanceMethods()),\n              undefined,\n              undefined,\n              ts.factory.createObjectLiteralExpression([], false)\n            )\n          ],\n          ts.NodeFlags.Const\n        )\n      );\n\n    }\n\n\n    export function generateBase(): ts.Node[] {\n      return [\n        generateStaticMethodsBase(),\n        generateInstanceMethodsBase(),\n      ]\n    }\n  }\n\n  export namespace relation {\n\n    export function extractRelationsFromDSL(dsl: Object): Relation[] {\n      return Object.entries(dsl)\n        .flatMap(([label, entry]) => {\n          const [[from, alias], [fromB, aliasB]] = Object.entries(entry) as string[][]\n\n          const inRel: Relation = {\n            from,\n            to: fromB,\n            direction: 'out',\n            label,\n            alias\n          }\n\n          const outRel: Relation = {\n            from: fromB,\n            to: from,\n            direction: 'in',\n            label: label,\n            alias: aliasB\n          }\n\n          return [inRel, outRel]\n        })\n    }\n\n\n    export function generateRelationsType(modelLabel: string, relations: Relation[]): [ts.InterfaceDeclaration, ModelToImport[]] {\n      const relationSchema = R.groupBy(rel => rel.from, relations)[modelLabel]!\n\n      const needToImportModels: string[] = relationSchema.map(rel => rel.to)\n\n      const modelRelations = relationSchema\n        .map(rel =>\n          createPropertySignature(\n            rel.alias,\n            ts.factory.createTypeReferenceNode('ModelRelatedNodesI', [\n              ts.factory.createTypeQueryNode(ts.factory.createIdentifier(rel.to)),\n              ts.factory.createTypeReferenceNode(rel.to + 'Instance', undefined),\n            ])))\n\n      const resultRelations = ts.factory.createInterfaceDeclaration(\n        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n        modelLabel + 'RelatedNodesI',\n        undefined,\n        undefined,\n        modelRelations,\n      );\n      return [resultRelations, needToImportModels]\n    }\n\n    export function generateRelationFile(rels: Relation[]): ts.Node[] {\n      const models = R.uniq(rels.flatMap(rel => [rel.from, rel.to]))\n\n      return [\n        ...models.map(imports.generateAllImportsOfModel),\n        ...rels.map(generateRelationInit)\n      ]\n    }\n\n    export function generateRelationInit(relation: Relation): ts.Node {\n      const traget = [\n        ts.factory.createPropertyAssignment(\n          ts.factory.createIdentifier('model'),\n          ts.factory.createIdentifier(relation.to)\n        ),\n        ts.factory.createPropertyAssignment(\n          ts.factory.createIdentifier('direction'),\n          ts.factory.createStringLiteral(relation.direction)\n        ),\n        ts.factory.createPropertyAssignment(\n          ts.factory.createIdentifier('name'),\n          ts.factory.createStringLiteral(relation.label)\n        )\n      ];\n\n      return ts.factory.createCallExpression(\n        ts.factory.createPropertyAccessExpression(\n          ts.factory.createIdentifier(relation.from),\n          ts.factory.createIdentifier('addRelationships')\n        ),\n        undefined,\n        [\n          ts.factory.createObjectLiteralExpression(\n            [\n              ts.factory.createPropertyAssignment(\n                ts.factory.createIdentifier(relation.alias),\n                ts.factory.createObjectLiteralExpression(\n                  traget,\n                  true // This flag is for multiline object literals\n                )\n              )\n            ],\n            true // This flag is for multiline object literals\n          )\n        ]\n      )\n    }\n  }\n\n  const lowerFirstChar = (str: string) =>\n    str.charAt(0).toLowerCase() + str.slice(1)\n\n  const createPropertySignature = (name: string, type: ts.TypeNode) =>\n    ts.factory.createPropertySignature(undefined, name, undefined, type)\n\n\n  const typeMapping: { [key: string]: ts.KeywordTypeSyntaxKind } = {\n    'string': ts.SyntaxKind.StringKeyword,\n    'boolean': ts.SyntaxKind.BooleanKeyword,\n    'number': ts.SyntaxKind.NumberKeyword,\n  }\n\n  const generatedFileClaim = '// GENERATED FILE, MAY CHANGE IN FUTURE, DO NOT EDIT IT MANUALLY\\n'\n\n  class GenerateSourceFile {\n    constructor(\n      readonly modelName: string | null | undefined,\n      readonly nodes: ts.Node[],\n      readonly type: FileType,\n    ) { }\n\n    save(ctx: ctx) {\n      const resultFile = ts.createSourceFile(\"\", \"\", ts.ScriptTarget.Latest, false, ts.ScriptKind.TSX);\n      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n      let printedNodes = this.nodes.map(node => printer.printNode(ts.EmitHint.Unspecified, node, resultFile)).join('\\n');\n\n      const resultCode = this.obtainWriteMode() == WriteMode.OVERRIDE ?\n        generatedFileClaim + printedNodes :\n        printedNodes\n\n\n      fs.mkdirSync(ctx.outputFolder, { recursive: true });\n\n      const pathToFile = `${ctx.outputFolder}/${this.obtainFileName()}`\n      const fileExists = fs.existsSync(pathToFile)\n\n      const minimalInfo = {\n        path: pathToFile,\n        model: this.modelName,\n        type: this.type,\n      }\n\n      if (this.obtainWriteMode() == WriteMode.CREATE_IF_NOT_EXISTS) {\n        if (!fileExists) {\n          fs.writeFileSync(pathToFile, resultCode);\n          logger.verbose('Created new file', minimalInfo)\n        } else {\n          logger.warn('File exists, skipped', minimalInfo)\n        }\n      } else if (this.obtainWriteMode() == WriteMode.OVERRIDE) {\n        fs.writeFileSync(pathToFile, resultCode);\n        if (fileExists) {\n          logger.verbose('File overridden:', minimalInfo);\n        } else {\n          logger.verbose('New file created:', minimalInfo);\n        }\n      } else {\n        logger.error('Nothing to do with this kind of file', minimalInfo)\n      }\n    }\n\n    obtainFileName(): string {\n      return R.cond([\n        [R.equals(FileType.MODEL), R.always(naming.file.forModel(this.modelName!))],\n        [R.equals(FileType.METHODS), R.always(naming.file.forModelMethods(this.modelName!))],\n        [R.equals(FileType.RELATION), R.always('__relations')],\n        [R.equals(FileType.BASE), R.always('__base')],\n      ])(this.type) + '.ts'\n    }\n\n    obtainWriteMode(): WriteMode {\n      return R.cond([\n        [R.equals(FileType.MODEL), R.always(WriteMode.OVERRIDE)],\n        [R.equals(FileType.RELATION), R.always(WriteMode.OVERRIDE)],\n        [R.T, R.always(WriteMode.CREATE_IF_NOT_EXISTS)]\n      ])(this.type)\n    }\n  }\n\n  const logger = createLogger({\n    level: \"silly\",\n    format: format.combine(\n      format.timestamp(),\n      format.ms(),\n      format.errors({ stack: true }),\n      format.splat(),\n      format.json()\n    ),\n    defaultMeta: { service: \"Test\" },\n    transports: [\n      new transports.Console({\n        format: format.combine(\n          format.colorize({ all: true }),\n          format.padLevels(),\n          consoleFormat({\n            showMeta: true,\n            metaStrip: [\"timestamp\", \"service\"],\n            inspectOptions: {\n              depth: Infinity,\n              colors: true,\n              maxArrayLength: Infinity,\n              breakLength: 120,\n              compact: Infinity,\n            },\n          })\n        ),\n      }),\n    ],\n  });\n\n\n  export function generateAll(ctx: ctx, schemas: Schema[], relations: RelationsDSL) {\n    try {\n      logger.silly(\"Started neogen\")\n      const parsedRelations = relation.extractRelationsFromDSL(relations)\n      logger.info(\"Parsed relations DSL\")\n\n      const sources = schemas.map((schema) =>\n        new GenerateSourceFile(\n          schema.label,\n          model.generateComposed(ctx, schema, parsedRelations),\n          FileType.MODEL));\n      logger.info(\"Generated types and props defenitions\")\n\n      sources.push(...methods.generateMethodFilesOf(ctx, sources))\n      logger.info(\"Generated methods files\")\n\n      sources.push(new GenerateSourceFile(null, relation.generateRelationFile(parsedRelations), FileType.RELATION))\n      logger.info(\"Generated relations file\")\n\n      if (ctx.generateBase) {\n        sources.push(new GenerateSourceFile(null, base.generateBase(), FileType.BASE))\n        logger.info(\"Generated base file\")\n      }\n\n      sources.map(it => it.save(ctx))\n\n      logger.silly('Done')\n    } catch (e) {\n      logger.error(e)\n    }\n  }\n\n  let instance: Neogma\n\n  export function get(): Neogma {\n    if (!instance) {\n      throw new Error('Ensure you call neogen.setInstance(noegmaInstance) and all imported in right order')\n    }\n    return instance\n  }\n\n  export function setInstance(val: Neogma): void {\n    instance = val\n  }\n\n}\n\n//////////////////////////////////////\n\n"],"mappings":"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","names":["neogen","FileType","WriteMode","naming","file","_","typing","ts","imports","common","model","props","instance","methods","base","relation","fs"]}