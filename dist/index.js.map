{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ModelFactory, ModelRelatedNodesI, Neogma, NeogmaInstance } from \"neogma\";\n// import { neogma } from \"../neo4j\";\nimport ts from \"typescript\";\nimport * as R from 'ramda';\nimport fs from 'fs';\nimport _ from 'lodash';\n\n//////////////////////////////////////\n\n///TODO\n///1) type of props Revalidator.ISchema<any> | Revalidator.JSONSchema<any>\n// 2) unions (model.generateSpeicifProp)\n// ts.factory.createUnionTypeNode([ // Union type (string | undefined)\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n//   ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword)\n// ])\n// ts.factory.createArrayLiteralExpression([\n//     ts.factory.createStringLiteral('string'),\n//     ts.factory.createStringLiteral('null')\n// ])\n//3) function for converting model name to file name\n//4) make more than two relations per label in (relation.extractRelationsFromDSL)\n//5) make it more DRY\n//6) add logging\nexport namespace neogen {\n    export enum FileType {\n        RELATION,\n        MODEL,\n        METHODS,\n        TOTAL,\n        BASE,\n    }\n\n    export enum WriteMode {\n        CREATE_IF_NOT_EXISTS,\n        OVERRIDE\n    }\n    export type PropType = { name: string, type: string }\n\n    export type ctx = {\n        outputFolder: string\n    }\n    type ModelToImport = string\n    export type Types = 'string' | 'boolean' | 'number'\n    export type PropsTypes = { [prop: string]: Types }\n    export type RelationsDSL = Object\n    export type Schema = {\n        label: string,\n        schema: PropsTypes\n    }\n    export type Relation = {\n        from: string,\n        to: string,\n        direction: 'out' | 'in',\n        label: string,\n        alias: string\n    }\n\n    export namespace naming {\n        export const instanceMethodsNameFor = (label: string) => lowerFirstChar(label) + 'InstanceMethods'\n        export const staticMethodsNameFor = (label: string) => lowerFirstChar(label) + 'StaticMethods'\n        export const instanceNameFor = (label: string) => label + 'Instance'\n\n        export namespace file {\n            export const forModel = (label: string) => _.snakeCase(label)\n            export const forModelMethods = (label: string) => '_' + _.snakeCase(label)\n        }\n    }\n\n    export namespace typing {\n        const typeOfIt = (label: string) => ts.factory.createTypeQueryNode(ts.factory.createIdentifier(label))\n\n        export const instanceMethodsNameFor = (label: string) => typeOfIt(naming.instanceMethodsNameFor(label))\n        export const staticMethodsNameFor = (label: string) => typeOfIt(naming.staticMethodsNameFor(label))\n    }\n\n    export namespace imports {\n\n        const importSpecifierFromName = (name: string) =>\n            ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier(name))\n\n        export function generateMethodsImport(modelName: string) {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        naming.instanceMethodsNameFor(modelName),\n                        naming.staticMethodsNameFor(modelName),\n                    ].map(importSpecifierFromName))\n                ),\n                ts.factory.createStringLiteral('./' + naming.file.forModelMethods(modelName)), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateStaticImports() {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        'ModelFactory',\n                        'ModelRelatedNodesI',\n                        'NeogmaInstance',\n                    ].map(importSpecifierFromName))\n                ),\n                ts.factory.createStringLiteral(\"neogma\"), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateNeogenImport() {\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports([\n                        importSpecifierFromName('neogen')\n                    ])\n                ),\n                ts.factory.createStringLiteral('neogen'), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n        export function generateAllImportsOfModel(modelName: string): ts.Node {\n            const toImport = [\n                modelName,\n                modelName + 'Instance',\n                modelName + 'Props',\n                modelName + 'RelatedNodesI',\n            ].map(importSpecifierFromName)\n\n            const importFrom = './' + naming.file.forModel(modelName)\n\n            return ts.factory.createImportDeclaration(\n                undefined, // modifiers array\n                ts.factory.createImportClause(\n                    false, // IsTypeOnly\n                    undefined, // No namespace import\n                    ts.factory.createNamedImports(toImport)\n                ),\n                ts.factory.createStringLiteral(importFrom), // module specifier\n                undefined  // assert clause\n            );\n        }\n\n\n    }\n\n    export namespace model {\n        function generatePropsType(schema: Schema): ts.TypeAliasDeclaration {\n            const propsTypes = Object.entries(schema.schema)\n                .map(([name, typeName]) => createPropertySignature(\n                    name,\n                    ts.factory.createKeywordTypeNode(typeMapping[typeName])\n                ))\n\n            return ts.factory.createTypeAliasDeclaration(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                schema.label + 'Props',\n                undefined,\n                ts.factory.createTypeLiteralNode(propsTypes)\n            )\n        }\n\n        export function generateComposed(ctx: ctx, schema: Schema, relations: Relation[]): ts.Node[] {\n            const [relationNodes, toImport] = relation.generateRelationsType(schema.label, relations)\n\n            const importBody: ts.Node[] = [\n                imports.generateStaticImports(),\n                imports.generateMethodsImport(schema.label),\n                imports.generateNeogenImport(),\n                ...R.uniq(toImport).map(imports.generateAllImportsOfModel),\n            ]\n\n            const body = [\n                generateInstanceType(schema.label),\n                generatePropsType(schema),\n                relationNodes,\n                generateModel(schema),\n            ].flatMap(it => [it, ts.factory.createEmptyStatement()])\n\n            return [\n                ...importBody, ...body\n            ]\n        }\n\n        function generateSpeicifProp(prop: PropType) {\n            return ts.factory.createPropertyAssignment(\n                prop.name,\n                ts.factory.createObjectLiteralExpression([\n                    ts.factory.createPropertyAssignment(\n                        'type',\n                        ts.factory.createStringLiteral(prop.type),\n                    )\n                ], false)\n            )\n        }\n\n        function generateModel(schema: Schema) {\n            const neogmaInstance =\n                ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier('neogen'),\n                    ts.factory.createIdentifier('get')\n                ),\n                undefined,\n                [])\n\n            const modelFactoryCall = ts.factory.createCallExpression(\n                ts.factory.createIdentifier('ModelFactory'), // Expression\n                [\n                    ts.factory.createTypeReferenceNode(schema.label + 'Props', undefined),\n                    ts.factory.createTypeReferenceNode(schema.label + 'RelatedNodesI', undefined),\n                    typing.staticMethodsNameFor(schema.label),\n                    typing.instanceMethodsNameFor(schema.label),\n\n                ],\n                [\n                    ts.factory.createObjectLiteralExpression([\n                        ts.factory.createPropertyAssignment(\n                            'methods', ts.factory.createIdentifier(naming.instanceMethodsNameFor(schema.label))\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'statics', ts.factory.createIdentifier(naming.staticMethodsNameFor(schema.label))\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'label',\n                            ts.factory.createStringLiteral(schema.label)\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'schema',\n                            ts.factory.createObjectLiteralExpression(\n                                Object.entries(schema.schema).map(([name, type]) => generateSpeicifProp({ name, type })) as any// schema.schema\n                                , true)\n                        ),\n                        ts.factory.createPropertyAssignment(\n                            'primaryKeyField',\n                            ts.factory.createStringLiteral('uuid')\n                        ),\n                    ], true),\n                    neogmaInstance\n                ]\n            );\n\n            const modelConst = ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [ts.factory.createVariableDeclaration(\n                        schema.label,\n                        undefined,\n                        undefined,\n                        modelFactoryCall\n                    )],\n                    ts.NodeFlags.Const\n                )\n            );\n\n            return modelConst\n        }\n    }\n\n    export namespace methods {\n        function generateStaticMethods(label: string): ts.Node {\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.staticMethodsNameFor(label)),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression([], false)\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n        }\n\n        function generateInstanceMethods(label: string): ts.Node {\n            const body = ts.factory.createBlock([\n                ts.factory.createReturnStatement(\n                    ts.factory.createAsExpression(\n                        ts.factory.createAsExpression(\n                            ts.factory.createThis(),\n                            ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n                        ),\n                        ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(naming.instanceNameFor(label)), undefined)\n                    )\n                )\n            ], true)\n\n            return ts.factory.createVariableStatement(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                ts.factory.createVariableDeclarationList(\n                    [\n                        ts.factory.createVariableDeclaration(\n                            ts.factory.createIdentifier(naming.instanceMethodsNameFor(label)),\n                            undefined,\n                            undefined,\n                            ts.factory.createObjectLiteralExpression(\n                                [\n                                    ts.factory.createMethodDeclaration(\n                                        undefined,\n                                        undefined,\n                                        ts.factory.createIdentifier(\"self\"),\n                                        undefined,\n                                        undefined,\n                                        [],\n                                        undefined,\n                                        body\n                                    )\n                                ],\n                                false\n                            )\n                        )\n                    ],\n                    ts.NodeFlags.Const\n                )\n            );\n\n        }\n\n        export function generateMethodFilesOf(files: GenerateSourceFile[]): GenerateSourceFile[] {\n            const mapToDeclaration =\n                (file: GenerateSourceFile) => [\n                    imports.generateAllImportsOfModel(file.modelName!),\n                    generateStaticMethods(file.modelName!),\n                    generateInstanceMethods(file.modelName!)\n                ]\n            return files.map(_ => new GenerateSourceFile(_.modelName, mapToDeclaration(_), FileType.METHODS))\n        }\n    }\n\n    export namespace relation {\n\n        export function extractRelationsFromDSL(dsl: Object): Relation[] {\n            return Object.entries(dsl)\n                .flatMap(([label, entry]) => {\n                    const [[from, alias], [fromB, aliasB]] = Object.entries(entry) as string[][]\n\n                    const inRel: Relation = {\n                        from,\n                        to: fromB,\n                        direction: 'out',\n                        label,\n                        alias\n                    }\n\n                    const outRel: Relation = {\n                        from: fromB,\n                        to: from,\n                        direction: 'in',\n                        label: label,\n                        alias: aliasB\n                    }\n\n                    return [inRel, outRel]\n                })\n        }\n\n\n        export function generateRelationsType(modelLabel: string, relations: Relation[]): [ts.InterfaceDeclaration, ModelToImport[]] {\n            const relationSchema = R.groupBy(rel => rel.from, relations)[modelLabel]!\n\n            const needToImportModels: string[] = relationSchema.map(rel => rel.to)\n\n            const modelRelations = relationSchema\n                .map(rel =>\n                    createPropertySignature(\n                        rel.alias,\n                        ts.factory.createTypeReferenceNode('ModelRelatedNodesI', [\n                            ts.factory.createTypeQueryNode(ts.factory.createIdentifier(rel.to)),\n                            ts.factory.createTypeReferenceNode(rel.to + 'Instance', undefined),\n                        ])))\n\n            const resultRelations = ts.factory.createInterfaceDeclaration(\n                [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n                modelLabel + 'RelatedNodesI',\n                undefined,\n                undefined,\n                modelRelations,\n            );\n            return [resultRelations, needToImportModels]\n        }\n\n        export function generateRelationFile(rels: Relation[]): ts.Node[] {\n            const models = R.uniq(rels.flatMap(rel => [rel.from, rel.to]))\n\n            return [\n                ...models.map(imports.generateAllImportsOfModel),\n                ...rels.map(generateRelationInit)\n            ]\n        }\n\n        export function generateRelationInit(relation: Relation): ts.Node {\n            const traget = [\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('model'),\n                    ts.factory.createIdentifier(relation.to)\n                ),\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('direction'),\n                    ts.factory.createStringLiteral(relation.direction)\n                ),\n                ts.factory.createPropertyAssignment(\n                    ts.factory.createIdentifier('name'),\n                    ts.factory.createStringLiteral(relation.label)\n                )\n            ];\n\n            return ts.factory.createCallExpression(\n                ts.factory.createPropertyAccessExpression(\n                    ts.factory.createIdentifier(relation.from),\n                    ts.factory.createIdentifier('addRelationships')\n                ),\n                undefined,\n                [\n                    ts.factory.createObjectLiteralExpression(\n                        [\n                            ts.factory.createPropertyAssignment(\n                                ts.factory.createIdentifier(relation.alias),\n                                ts.factory.createObjectLiteralExpression(\n                                    traget,\n                                    true // This flag is for multiline object literals\n                                )\n                            )\n                        ],\n                        true // This flag is for multiline object literals\n                    )\n                ]\n            )\n        }\n    }\n\n    const lowerFirstChar = (str: string) =>\n        str.charAt(0).toLowerCase() + str.slice(1)\n\n    const createPropertySignature = (name: string, type: ts.TypeNode) =>\n        ts.factory.createPropertySignature(undefined, name, undefined, type)\n\n\n    const typeMapping: { [key: string]: ts.KeywordTypeSyntaxKind } = {\n        'string': ts.SyntaxKind.StringKeyword,\n        'boolean': ts.SyntaxKind.BooleanKeyword,\n        'number': ts.SyntaxKind.NumberKeyword,\n    }\n\n\n    function generateInstanceType(label: string): ts.TypeAliasDeclaration {\n\n        const instanceMethodsName = naming.instanceMethodsNameFor(label)\n\n        const neogmaInstanceType = ts.factory.createTypeReferenceNode('NeogmaInstance', [\n            ts.factory.createTypeReferenceNode(label + 'Props', undefined),\n            ts.factory.createTypeReferenceNode(label + 'RelatedNodesI', undefined),\n            ts.factory.createTypeQueryNode(ts.factory.createIdentifier(instanceMethodsName))\n        ]);\n\n        return ts.factory.createTypeAliasDeclaration(\n            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n            label + 'Instance',\n            [], // Type parameters\n            neogmaInstanceType,\n        );\n    }\n\n    const generatedFileClaim = '// GENERATED FILE, MAY CHANGE IN FUTURE, DO NOT EDIT IT MANUALLY\\n'\n\n    class GenerateSourceFile {\n        constructor(\n            readonly modelName: string | null | undefined,\n            readonly nodes: ts.Node[],\n            readonly type: FileType,\n        ) { }\n\n        save(ctx: ctx) {\n            const resultFile = ts.createSourceFile(\"\", \"\", ts.ScriptTarget.Latest, false, ts.ScriptKind.TSX);\n            const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n            let printedNodes = this.nodes.map(node => printer.printNode(ts.EmitHint.Unspecified, node, resultFile)).join('\\n');\n\n            const resultCode = this.obtainWriteMode() == WriteMode.OVERRIDE ?\n                generatedFileClaim + printedNodes :\n                printedNodes\n\n\n            fs.mkdirSync(ctx.outputFolder, { recursive: true });\n\n            const pathToFile = `${ctx.outputFolder}/${this.obtainFileName()}`\n\n            if (this.obtainWriteMode() == WriteMode.CREATE_IF_NOT_EXISTS && !fs.existsSync(pathToFile)) {\n                fs.writeFileSync(pathToFile, resultCode);\n            } else if (this.obtainWriteMode() == WriteMode.OVERRIDE) {\n                fs.writeFileSync(pathToFile, resultCode);\n            }\n        }\n\n        obtainFileName(): string {\n            return R.cond([\n                [R.equals(FileType.MODEL), R.always(naming.file.forModel(this.modelName!))],\n                [R.equals(FileType.METHODS), R.always(naming.file.forModelMethods(this.modelName!))],\n                [R.equals(FileType.RELATION), R.always('__relations')],\n            ])(this.type) + '.ts'\n        }\n\n        obtainWriteMode(): WriteMode {\n            return R.cond([\n                [R.equals(FileType.MODEL), R.always(WriteMode.OVERRIDE)],\n                [R.equals(FileType.RELATION), R.always(WriteMode.OVERRIDE)],\n                [R.T, R.always(WriteMode.CREATE_IF_NOT_EXISTS)]\n            ])(this.type)\n        }\n    }\n\n\n    export function generateAll(ctx: ctx, schemas: Schema[], relations: RelationsDSL) {\n        const parsedRelations = relation.extractRelationsFromDSL(relations)\n\n        const sources = schemas.map((schema) =>\n            new GenerateSourceFile(\n                schema.label,\n                model.generateComposed(ctx, schema, parsedRelations),\n                FileType.MODEL));\n\n        sources.push(...methods.generateMethodFilesOf(sources))\n        sources.push(new GenerateSourceFile(null, relation.generateRelationFile(parsedRelations), FileType.RELATION))\n        sources.map(it => it.save(ctx))\n    }\n\n    function print(nodes: any) {\n        const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n        const resultFile = ts.createSourceFile(\n            \"\",\n            \"\",\n            ts.ScriptTarget.Latest,\n            false,\n            ts.ScriptKind.TSX\n        );\n\n        const result = printer.printList(ts.ListFormat.MultiLine, nodes, resultFile);\n\n        console.log(\n            result.split(';\\n').join('\\n'))\n\n    }\n\n    console.log('init')\n    let instance: Neogma\n\n    export function get(): Neogma {\n        console.log('get')\n        if (!instance) {\n            throw new Error('Ensure you call neogen.setInstance(noegmaInstance) and all imported in right order')\n        }\n        return instance\n    }\n\n    export function setInstance(val: Neogma): void {\n        console.log('set')\n\n        instance = val\n    }\n\n}\n\n//////////////////////////////////////\n\n"],"mappings":"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","names":["neogen","FileType","WriteMode","naming","file","_","typing","ts","imports","model","methods","relation","fs"]}